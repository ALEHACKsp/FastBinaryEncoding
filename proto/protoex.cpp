// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: protoex.fbe
// Version: 1.3.0.0

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "protoex.h"

namespace protoex {

Order::Order()
    : id((int32_t)0ll)
    , symbol()
    , side()
    , type()
    , price((double)0.0)
    , volume((double)0.0)
    , tp((double)10.0)
    , sl((double)-10.0)
{}

Order::Order(int32_t arg_id, const std::string& arg_symbol, const ::protoex::OrderSide& arg_side, const ::protoex::OrderType& arg_type, double arg_price, double arg_volume, double arg_tp, double arg_sl)
    : id(arg_id)
    , symbol(arg_symbol)
    , side(arg_side)
    , type(arg_type)
    , price(arg_price)
    , volume(arg_volume)
    , tp(arg_tp)
    , sl(arg_sl)
{}

bool Order::operator==(const Order& other) const noexcept
{
    return (
        (id == other.id)
        );
}

bool Order::operator<(const Order& other) const noexcept
{
    if (id < other.id)
        return true;
    if (other.id < id)
        return false;
    return false;
}

void Order::swap(Order& other) noexcept
{
    using std::swap;
    swap(id, other.id);
    swap(symbol, other.symbol);
    swap(side, other.side);
    swap(type, other.type);
    swap(price, other.price);
    swap(volume, other.volume);
    swap(tp, other.tp);
    swap(sl, other.sl);
}

Balance::Balance()
    : ::proto::Balance()
    , locked((double)0.0)
{}

Balance::Balance(const ::proto::Balance& base, double arg_locked)
    : ::proto::Balance(base)
    , locked(arg_locked)
{}

bool Balance::operator==(const Balance& other) const noexcept
{
    return (
        ::proto::Balance::operator==(other)
        && true
        );
}

bool Balance::operator<(const Balance& other) const noexcept
{
    if (::proto::Balance::operator<(other))
        return true;
    if (other.::proto::Balance::operator<(*this))
        return false;
    return false;
}

void Balance::swap(Balance& other) noexcept
{
    using std::swap;
    ::proto::Balance::swap(other);
    swap(locked, other.locked);
}

Account::Account()
    : id((int32_t)0ll)
    , name()
    , state(StateEx::initialized  |  StateEx::bad  |  StateEx::sad)
    , wallet()
    , asset()
    , orders()
{}

Account::Account(int32_t arg_id, const std::string& arg_name, const ::protoex::StateEx& arg_state, const ::protoex::Balance& arg_wallet, const std::optional<::protoex::Balance>& arg_asset, const std::vector<::protoex::Order>& arg_orders)
    : id(arg_id)
    , name(arg_name)
    , state(arg_state)
    , wallet(arg_wallet)
    , asset(arg_asset)
    , orders(arg_orders)
{}

bool Account::operator==(const Account& other) const noexcept
{
    return (
        (id == other.id)
        );
}

bool Account::operator<(const Account& other) const noexcept
{
    if (id < other.id)
        return true;
    if (other.id < id)
        return false;
    return false;
}

void Account::swap(Account& other) noexcept
{
    using std::swap;
    swap(id, other.id);
    swap(name, other.name);
    swap(state, other.state);
    swap(wallet, other.wallet);
    swap(asset, other.asset);
    swap(orders, other.orders);
}

OrderMessage::OrderMessage()
    : body()
{}

OrderMessage::OrderMessage(const ::protoex::Order& arg_body)
    : body(arg_body)
{}

bool OrderMessage::operator==(const OrderMessage& other) const noexcept
{
    return (
        true
        );
}

bool OrderMessage::operator<(const OrderMessage& other) const noexcept
{
    return false;
}

void OrderMessage::swap(OrderMessage& other) noexcept
{
    using std::swap;
    swap(body, other.body);
}

BalanceMessage::BalanceMessage()
    : body()
{}

BalanceMessage::BalanceMessage(const ::protoex::Balance& arg_body)
    : body(arg_body)
{}

bool BalanceMessage::operator==(const BalanceMessage& other) const noexcept
{
    return (
        true
        );
}

bool BalanceMessage::operator<(const BalanceMessage& other) const noexcept
{
    return false;
}

void BalanceMessage::swap(BalanceMessage& other) noexcept
{
    using std::swap;
    swap(body, other.body);
}

AccountMessage::AccountMessage()
    : body()
{}

AccountMessage::AccountMessage(const ::protoex::Account& arg_body)
    : body(arg_body)
{}

bool AccountMessage::operator==(const AccountMessage& other) const noexcept
{
    return (
        true
        );
}

bool AccountMessage::operator<(const AccountMessage& other) const noexcept
{
    return false;
}

void AccountMessage::swap(AccountMessage& other) noexcept
{
    using std::swap;
    swap(body, other.body);
}

} // namespace protoex
