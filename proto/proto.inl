// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: proto.fbe
// Version: 1.3.0.0

namespace proto {

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, OrderSide value)
{
    if (value == OrderSide::buy) { stream << "buy"; return stream; }
    if (value == OrderSide::sell) { stream << "sell"; return stream; }
    stream << "<unknown>";
    return stream;
}

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, OrderType value)
{
    if (value == OrderType::market) { stream << "market"; return stream; }
    if (value == OrderType::limit) { stream << "limit"; return stream; }
    if (value == OrderType::stop) { stream << "stop"; return stream; }
    stream << "<unknown>";
    return stream;
}

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, State value)
{
    bool first = true;
    if ((value & State::unknown) && ((value & State::unknown) == State::unknown))
    {
        stream << (first ? "" : "|") << "unknown";
        first = false;
    }
    if ((value & State::invalid) && ((value & State::invalid) == State::invalid))
    {
        stream << (first ? "" : "|") << "invalid";
        first = false;
    }
    if ((value & State::initialized) && ((value & State::initialized) == State::initialized))
    {
        stream << (first ? "" : "|") << "initialized";
        first = false;
    }
    if ((value & State::calculated) && ((value & State::calculated) == State::calculated))
    {
        stream << (first ? "" : "|") << "calculated";
        first = false;
    }
    if ((value & State::broken) && ((value & State::broken) == State::broken))
    {
        stream << (first ? "" : "|") << "broken";
        first = false;
    }
    if ((value & State::good) && ((value & State::good) == State::good))
    {
        stream << (first ? "" : "|") << "good";
        first = false;
    }
    if ((value & State::bad) && ((value & State::bad) == State::bad))
    {
        stream << (first ? "" : "|") << "bad";
        first = false;
    }
    return stream;
}

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const Order& value)
{
    stream << "Order(";
    stream << "id="; stream << value.id;
    stream << ",symbol="; stream << "\"" << value.symbol << "\"";
    stream << ",side="; stream << value.side;
    stream << ",type="; stream << value.type;
    stream << ",price="; stream << value.price;
    stream << ",volume="; stream << value.volume;
    stream << ")";
    return stream;
}

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const Balance& value)
{
    stream << "Balance(";
    stream << "currency="; stream << "\"" << value.currency << "\"";
    stream << ",amount="; stream << value.amount;
    stream << ")";
    return stream;
}

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const Account& value)
{
    stream << "Account(";
    stream << "id="; stream << value.id;
    stream << ",name="; stream << "\"" << value.name << "\"";
    stream << ",state="; stream << value.state;
    stream << ",wallet="; stream << value.wallet;
    stream << ",asset="; if (value.asset) stream << *value.asset; else stream << "null";
    {
        bool first = true;
        stream << ",orders=[" << value.orders.size() << "][";
        for (const auto& it : value.orders)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const OrderMessage& value)
{
    stream << "OrderMessage(";
    stream << "body="; stream << value.body;
    stream << ")";
    return stream;
}

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const BalanceMessage& value)
{
    stream << "BalanceMessage(";
    stream << "body="; stream << value.body;
    stream << ")";
    return stream;
}

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const AccountMessage& value)
{
    stream << "AccountMessage(";
    stream << "body="; stream << value.body;
    stream << ")";
    return stream;
}

} // namespace proto
